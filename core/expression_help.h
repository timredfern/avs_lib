// avs_lib - Portable Advanced Visualization Studio library
// Based on Advanced Visualization Studio by Nullsoft, Inc.
// AVS Copyright (C) 2005 Nullsoft, Inc.
// C++20 port Copyright (C) 2025 Tim Redfern
// Licensed under MIT License

#pragma once

namespace avs {
namespace expression_help {

// Help text tabs - matches original AVS IDD_EVAL_HELP dialog
// These are displayed in a tabbed help window when user clicks "expression help"

inline const char* general() {
    return
        "Many AVS effects allow you to write simple expressions to control\n"
        "visualization. Here is a brief summary of how to write AVS code.\n"
        "\n"
        "Many aspects of AVS code are similar to C (including comments).\n"
        "\n"
        "You can create new variables just by using them, and you can read\n"
        "and write predefined variables (of which each effect has its own)\n"
        "to interact with the effect. Note that variables are all floating\n"
        "point numbers (no strings), and the maximum length of a variable's\n"
        "name is 8 characters (anything longer will be ignored).\n"
        "\n"
        "So, to create a variable, you can simply use it, for example:\n"
        "  x = 5;\n"
        "\n"
        "You can also use a variety of operators and math functions to\n"
        "modify variables, see the Operators and Functions tabs above.\n"
        "\n"
        "Code can include C and C++ style comments:\n"
        "  // using the doubleslash comments until the end of the line\n"
        "  /* using the classic C comments\n"
        "     comment a block of text */\n"
        "\n"
        "You can combine operators and functions into expressions, such as:\n"
        "  x = 5 * cos(y) / 32.0; // this does some leetness right here\n"
        "\n"
        "You can use multiple expressions by separating them with one or\n"
        "more semicolons, for example:\n"
        "  x = x * 17.0; x = x / 5; y = pow(x,3.0);\n"
        "\n"
        "It is worth noting that extra whitespace (spaces, newlines) is\n"
        "ignored, so if you need to space things out for clarity, you can.\n";
}

inline const char* operators() {
    return
        "The following operators are available:\n"
        "\n"
        "=\n"
        "  assigns a value to a variable.\n"
        "  example:  var=5;\n"
        "\n"
        "+\n"
        "  adds two values, returns the sum.\n"
        "  example:  var=5+var2;\n"
        "\n"
        "-\n"
        "  subtracts two values, returns the difference.\n"
        "  example:  var=5-var2;\n"
        "\n"
        "*\n"
        "  multiplies two values, returns the product.\n"
        "  example:  var=5*var2;\n"
        "\n"
        "/\n"
        "  divides two values, returns the quotient.\n"
        "  example:  var=5/var2;\n"
        "\n"
        "%\n"
        "  converts two values to integer, performs division, returns remainder\n"
        "  example:  var=var2%5;\n"
        "\n"
        "|\n"
        "  converts two values to integer, returns bitwise OR of both values\n"
        "  example:  var=var2|31;\n"
        "\n"
        "&\n"
        "  converts two values to integer, returns bitwise AND of both values\n"
        "  example:  var=var2&31;\n";
}

inline const char* comparisons() {
    return
        "Comparison operators return 1.0 (true) or 0.0 (false).\n"
        "Two syntaxes are available - use whichever you prefer:\n"
        "\n"
        "  Operation        Operator    Function\n"
        "  ------------------------------------------------\n"
        "  Less than        a < b       below(a, b)\n"
        "  Greater than     a > b       above(a, b)\n"
        "  Equal            a == b      equal(a, b)\n"
        "  Less or equal    a <= b      -\n"
        "  Greater or equal a >= b      -\n"
        "  Not equal        a != b      -\n"
        "\n"
        "Examples:\n"
        "  // Operator syntax (recommended)\n"
        "  skip = (c < 0.5) & (sq > 0);\n"
        "  valid = if(i < count, 1, 0);\n"
        "\n"
        "  // Function syntax (legacy)\n"
        "  skip = below(c, 0.5) & above(sq, 0);\n"
        "  valid = if(below(i, count), 1, 0);\n"
        "\n"
        "Note: Comparisons bind tighter than & and | but looser than + and -\n"
        "  3 + 2 < 10   means   (3 + 2) < 10   (evaluates to 1.0)\n"
        "  x < 5 & y > 0  means  (x < 5) & (y > 0)\n";
}

inline const char* functions() {
    return
        "Functions available from code:\n"
        "\n"
        "abs(value)\n"
        "  returns the absolute value of 'value'\n"
        "\n"
        "sin(value)\n"
        "  returns the sine of the radian angle 'value'\n"
        "\n"
        "cos(value)\n"
        "  returns the cosine of the radian angle 'value'\n"
        "\n"
        "tan(value)\n"
        "  returns the tangent of the radian angle 'value'\n"
        "\n"
        "asin(value)\n"
        "  returns the arcsine (in radians) of 'value'\n"
        "\n"
        "acos(value)\n"
        "  returns the arccosine (in radians) of 'value'\n"
        "\n"
        "atan(value)\n"
        "  returns the arctangent (in radians) of 'value'\n"
        "\n"
        "atan2(value1, value2)\n"
        "  returns the arctangent (in radians) of value1/value2\n"
        "\n"
        "sqr(value)\n"
        "  returns the square of 'value'\n"
        "\n"
        "sqrt(value)\n"
        "  returns the square root of 'value'\n"
        "\n"
        "pow(value, power)\n"
        "  returns 'value' raised to the power of 'power'\n"
        "\n"
        "exp(value)\n"
        "  returns e raised to the power of 'value'\n"
        "\n"
        "log(value)\n"
        "  returns the natural logarithm of 'value'\n"
        "\n"
        "log10(value)\n"
        "  returns the base-10 logarithm of 'value'\n"
        "\n"
        "floor(value)\n"
        "  returns the largest integer less than or equal to 'value'\n"
        "\n"
        "ceil(value)\n"
        "  returns the smallest integer greater than or equal to 'value'\n"
        "\n"
        "sign(value)\n"
        "  returns the sign of 'value' (-1, 0, or 1)\n"
        "\n"
        "min(value1, value2)\n"
        "  returns the smaller of value1 and value2\n"
        "\n"
        "max(value1, value2)\n"
        "  returns the larger of value1 and value2\n"
        "\n"
        "sigmoid(value, constraint)\n"
        "  returns a smooth curve between -1 and 1\n"
        "\n"
        "rand(max)\n"
        "  returns a random integer between 0 and max-1\n"
        "\n"
        "band(value1, value2)\n"
        "  returns 1 if both value1 and value2 are nonzero, 0 otherwise\n"
        "\n"
        "bor(value1, value2)\n"
        "  returns 1 if either value1 or value2 are nonzero, 0 otherwise\n"
        "\n"
        "bnot(value)\n"
        "  returns 1 if value is zero, 0 otherwise\n"
        "\n"
        "if(condition, value1, value2)\n"
        "  if condition is nonzero, returns value1, otherwise returns value2\n"
        "\n"
        "equal(value1, value2)\n"
        "  returns 1 if value1 equals value2, 0 otherwise\n"
        "  (also available as: value1 == value2)\n"
        "\n"
        "above(value1, value2)\n"
        "  returns 1 if value1 is greater than value2, 0 otherwise\n"
        "  (also available as: value1 > value2)\n"
        "\n"
        "below(value1, value2)\n"
        "  returns 1 if value1 is less than value2, 0 otherwise\n"
        "  (also available as: value1 < value2)\n"
        "\n"
        "See the Comparisons tab for the full list of comparison operators.\n"
        "\n"
        "getosc(band, width, channel)\n"
        "  returns waveform data. band is 0-1, width is 0-1, channel: 0=center, 1=left, 2=right\n"
        "\n"
        "getspec(band, width, channel)\n"
        "  returns spectrum data. band is 0-1, width is 0-1, channel: 0=center, 1=left, 2=right\n"
        "\n"
        "gettime(value)\n"
        "  returns time: 0=seconds since midnight, 1=hours, 2=minutes, 3=seconds\n"
        "\n"
        "getkbmouse(value)\n"
        "  returns keyboard/mouse state (see documentation for values)\n"
        "\n"
        "megabuf(index)\n"
        "  accesses the megabuf array at 'index' (0 to 1048575)\n"
        "\n"
        "gmegabuf(index)\n"
        "  accesses the global megabuf array (shared between effects)\n"
        "\n"
        "assign(dest, value)\n"
        "  assigns 'value' to 'dest' and returns value\n"
        "\n"
        "exec2(expr1, expr2)\n"
        "  evaluates expr1, then expr2, returns result of expr2\n"
        "\n"
        "exec3(expr1, expr2, expr3)\n"
        "  evaluates all three expressions, returns result of expr3\n"
        "\n"
        "loop(count, expr)\n"
        "  evaluates 'expr' 'count' times\n"
        "\n"
        "while(expr)\n"
        "  evaluates 'expr' until it returns zero\n";
}

inline const char* constants() {
    return
        "The following constants are available:\n"
        "\n"
        "$PI\n"
        "  the value of pi (3.14159265358979...)\n"
        "\n"
        "$E\n"
        "  the value of e (2.71828182845904...)\n"
        "\n"
        "$PHI\n"
        "  the golden ratio (1.61803398874989...)\n";
}

inline const char* midi() {
    return
        "MIDI data is available via arrays and variables:\n"
        "\n"
        "midi_cc[n]\n"
        "  returns CC value for controller n (0-127)\n"
        "  values are normalized 0.0 to 1.0\n"
        "\n"
        "midi_note[n]\n"
        "  returns velocity for note n (0-127)\n"
        "  0.0 = note off, 0.0-1.0 = note on with velocity\n"
        "\n"
        "midi_note_index[i]\n"
        "  returns note number at position i in active notes list\n"
        "  use with midi_note_count to iterate active notes\n"
        "\n"
        "midi_note_count\n"
        "  number of currently held notes\n"
        "\n"
        "midi_any_note\n"
        "  1.0 if any note was triggered this frame, 0.0 otherwise\n"
        "\n"
        "midi_pitch_bend\n"
        "  pitch bend value, -1.0 to 1.0 (0.0 = center)\n"
        "\n"
        "Example - modwheel controls rotation:\n"
        "  r = midi_cc[1] * $PI * 2;\n"
        "\n"
        "Example - respond to specific notes:\n"
        "  vel = midi_note[60]; // middle C velocity\n"
        "  size = 0.5 + vel * 0.5;\n"
        "\n"
        "Example - iterate all active notes:\n"
        "  i = 0;\n"
        "  while(below(i, midi_note_count),\n"
        "    note = midi_note_index[i];\n"
        "    vel = midi_note[note];\n"
        "    // do something with note and vel\n"
        "    i = i + 1\n"
        "  );\n";
}

inline const char* arrays() {
    return
        "User-defined arrays let you store and retrieve values by index:\n"
        "\n"
        "Writing to arrays:\n"
        "  myarray[0] = 5.0;\n"
        "  myarray[i] = cos(angle);\n"
        "  shape_x[n] = x_position;\n"
        "\n"
        "Reading from arrays:\n"
        "  x = myarray[0];\n"
        "  pos = shape_x[index];\n"
        "\n"
        "Arrays auto-create on first write and auto-grow as needed.\n"
        "Reading an unwritten index returns 0.0.\n"
        "Arrays persist across script phases (init/frame/beat/point).\n"
        "\n"
        "Example - pre-calculate geometry in frame, use in point:\n"
        "\n"
        "  frame:\n"
        "    num = midi_note_count;\n"
        "    i = 0;\n"
        "    while(i < num,\n"
        "      note = midi_note_index[i];\n"
        "      shape_x[i] = cos(note * 0.1) * 0.5;\n"
        "      shape_y[i] = sin(note * 0.1) * 0.5;\n"
        "      shape_sz[i] = midi_note[note] * 0.2;\n"
        "      i = i + 1\n"
        "    );\n"
        "\n"
        "  point:\n"
        "    idx = floor(i * num);\n"
        "    x = shape_x[idx];\n"
        "    y = shape_y[idx];\n"
        "    // Much faster than calculating trig per-point!\n";
}

} // namespace expression_help
} // namespace avs
